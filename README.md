# heatshrink_byte

This is a modified version of the https://github.com/snakehand/heatshrink


**Description**

The main difference is you decompress/read the decompressed data byte per byte.

It is useful for use cases such as font compression etc.. where the output can be big
and you process them in little chunks (byte)

You need to know the output size, it is driven by the consumer NOT by the compressed data size. In other words, you are expected to stop consuming when the original data have been retrieved.

_/!\ The window size is hardcoded to be 7 maximum, length =4 /!\\_

This is to cap the consumed buffer memory to about 256 bytes

**CLI encoder**

To get a basic CLI encoder:\
>_cargo build -  * -features=encode_*

the resulting executable is in _target/debug/heatshrink-rust_

**Usage**

  >let hs = heatshrink::HeatshrinkDecoder::new( &compressed_data, &(heatshrink::Config::new(7,4).unwrap()));\
  >while(you need data) {let one_bye=hs.next();}\

or if you want to decompress later
>let hs = heatshrink::HeatshrinkDecoder::new( &[], & heatshrink::Config::new(7,4).unwrap()));\
> ...\
> ...\
> hs.reset(&compressed_data);\
>while(you need data) {let one_bye=hs.next();}



The &[] can be replaced by the compressed data if it is a simple use case.\
hs.reset(data_to_decode); // if you want to decode another buffer

**Warning**

1- As far as i can tell, the compressed binaries are not necessarily compatible with original C language heatshrink!.

Use the encoder from heatshrink rust.

The binaries generated by this version *are* compatible with the original snakehand version.

2- Make sure the encoder   & decoder have the same configuration. I strongly suggest to use the default 7/4 that are more or less hardcoded anyway.

3- There is little error handling by design.

--

**Original description :**

Minimal no_std implementation of Heatshrink compression &amp; decompression
